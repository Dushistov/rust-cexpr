var searchIndex = {};
searchIndex["cexpr"] = {"doc":"","items":[[4,"Error","cexpr","Parsing errors specific to C parsing",null,null],[13,"ExactToken","","Expected the specified token",0,null],[13,"TypedToken","","Expected a token of the specified kind",0,null],[13,"UnknownIdentifier","","An unknown identifier was encountered",0,null],[13,"InvalidLiteral","","An invalid literal was encountered.",0,null],[13,"Partial","","A full parse was requested, but data was left over after parsing finished.",0,null],[5,"assert_full_parse","","If the input result indicates a succesful parse, but there is data left,\nreturn an `Error::Partial` instead.",null,{"inputs":[{"name":"iresult"}],"output":{"name":"iresult"}}],[0,"nom","","nom&#39;s result types, re-exported.",null,null],[11,"is_done","nom::internal","",1,null],[11,"is_err","","",1,null],[11,"is_incomplete","","",1,null],[11,"map","","Maps a `IResult&lt;I, O, E&gt;` to `IResult&lt;I, N, E&gt;` by appling a function\nto a contained `Done` value, leaving `Error` and `Incomplete` value\nuntouched.",1,null],[11,"map_inc","","Maps a `IResult&lt;I, O, E&gt;` to `IResult&lt;I, O, E&gt;` by appling a function\nto a contained `Incomplete` value, leaving `Done` and `Error` value\nuntouched.",1,null],[11,"map_err","","Maps a `IResult&lt;I, O, E&gt;` to `IResult&lt;I, O, N&gt;` by appling a function\nto a contained `Error` value, leaving `Done` and `Incomplete` value\nuntouched.",1,null],[11,"clone","nom::util","",2,null],[11,"hash","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"fmt","","",2,null],[11,"description","","",2,null],[11,"clone","nom::internal","",3,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"fmt","","",3,null],[11,"clone","","",4,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"fmt","","",4,null],[11,"is_known","","",4,null],[11,"map","","Maps a `Needed` to `Needed` by appling a function to a contained `Size` value.",4,null],[11,"clone","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"fmt","","",1,null],[11,"remaining_input","","",1,null],[11,"remaining_input","","",1,null],[11,"remaining_input","","",1,null],[11,"output","","",1,null],[11,"output","","",1,null],[11,"output","","",1,null],[11,"description","","",3,null],[11,"fmt","","",3,null],[11,"clone","nom::stream","",5,null],[11,"fmt","","",5,null],[11,"clone","","",6,null],[11,"fmt","","",6,null],[11,"map","","",6,null],[11,"flat_map","","",6,null],[11,"apply","","",7,null],[11,"new","","",8,null],[11,"eq","","",9,null],[11,"ne","","",9,null],[11,"clone","","",9,null],[11,"fmt","","",9,null],[11,"apply","","",8,null],[11,"eq","","",10,null],[11,"clone","","",10,null],[11,"fmt","","",10,null],[11,"fmt","","",11,null],[11,"new","","",11,{"inputs":[{"name":"str"},{"name":"usize"}],"output":{"name":"result"}}],[11,"state","","",11,null],[11,"refill","","",11,null],[11,"resize","","Resize the internal buffer, copy the data to the new one and returned how much data was copied",11,null],[11,"apply","","",11,null],[11,"new","","",12,{"inputs":[{"name":"c"},{"name":"f"}],"output":{"name":"mapconsumer"}}],[11,"handle","","",12,null],[11,"state","","",12,null],[11,"new","","",13,{"inputs":[{"name":"c1"},{"name":"c2"}],"output":{"name":"chainconsumer"}}],[11,"handle","","",13,null],[11,"state","","",13,null],[4,"IResult","cexpr::nom","Holds the result of parsing functions",null,null],[13,"Done","","indicates a correct parsing, the first field containing the rest of the unparsed data, the second field contains the parsed data",1,null],[13,"Error","","contains a Err, an enum that can indicate an error code, a position in the input, and a pointer to another error, making a list of errors in the parsing tree",1,null],[13,"Incomplete","","Incomplete contains a Needed, an enum than can represent a known quantity of input data, or unknown",1,null],[4,"Needed","","Contains information on needed data if a parser returned `Incomplete`",null,null],[13,"Unknown","","needs more data, but we do not know how much",4,null],[13,"Size","","contains the required data size",4,null],[4,"Err","","Contains the error that a parser can return",null,null],[13,"Code","","An error code, represented by an ErrorKind, which can contain a custom error code represented by E",3,null],[13,"Node","","An error code, and the next error",3,null],[13,"Position","","An error code, and the input position",3,null],[13,"NodePosition","","An error code, the input position and the next error",3,null],[4,"ErrorKind","","indicates which parser returned an error",null,null],[13,"Custom","","",2,null],[13,"Tag","","",2,null],[13,"MapRes","","",2,null],[13,"MapOpt","","",2,null],[13,"Alt","","",2,null],[13,"IsNot","","",2,null],[13,"IsA","","",2,null],[13,"SeparatedList","","",2,null],[13,"SeparatedNonEmptyList","","",2,null],[13,"Many0","","",2,null],[13,"Many1","","",2,null],[13,"Count","","",2,null],[13,"TakeUntilAndConsume","","",2,null],[13,"TakeUntil","","",2,null],[13,"TakeUntilEitherAndConsume","","",2,null],[13,"TakeUntilEither","","",2,null],[13,"LengthValue","","",2,null],[13,"TagClosure","","",2,null],[13,"Alpha","","",2,null],[13,"Digit","","",2,null],[13,"HexDigit","","",2,null],[13,"OctDigit","","",2,null],[13,"AlphaNumeric","","",2,null],[13,"Space","","",2,null],[13,"MultiSpace","","",2,null],[13,"LengthValueFn","","",2,null],[13,"Eof","","",2,null],[13,"ExprOpt","","",2,null],[13,"ExprRes","","",2,null],[13,"CondReduce","","",2,null],[13,"Switch","","",2,null],[13,"TagBits","","",2,null],[13,"OneOf","","",2,null],[13,"NoneOf","","",2,null],[13,"Char","","",2,null],[13,"CrLf","","",2,null],[13,"RegexpMatch","","",2,null],[13,"RegexpMatches","","",2,null],[13,"RegexpFind","","",2,null],[13,"RegexpCapture","","",2,null],[13,"RegexpCaptures","","",2,null],[13,"TakeWhile1","","",2,null],[13,"Complete","","",2,null],[13,"Fix","","",2,null],[13,"Escaped","","",2,null],[13,"EscapedTransform","","",2,null],[13,"TagStr","","",2,null],[13,"IsNotStr","","",2,null],[13,"IsAStr","","",2,null],[13,"TakeWhile1Str","","",2,null],[13,"NonEmpty","","",2,null],[13,"ManyMN","","",2,null],[13,"TakeUntilAndConsumeStr","","",2,null],[13,"TakeUntilStr","","",2,null],[0,"literal","cexpr","Parsing C literals from byte slices.",null,null],[4,"CChar","cexpr::literal","Representation of a C character",null,null],[13,"Char","","A character that can be represented as a `char`",14,null],[13,"Raw","","Any other character (8-bit characters, unicode surrogates, etc.)",14,null],[5,"parse","","Parse a C literal.",null,null],[11,"eq","","",14,null],[11,"ne","","",14,null],[11,"clone","","",14,null],[11,"fmt","","",14,null],[11,"from","","",14,{"inputs":[{"name":"u8"}],"output":{"name":"cchar"}}],[11,"into","","",14,null],[0,"expr","cexpr","Evaluating C expressions from tokens.",null,null],[3,"IdentifierParser","cexpr::expr","Expression parser/evaluator that supports identifiers.",null,null],[4,"EvalResult","","The result of parsing a literal or evaluating an expression.",null,null],[13,"Int","","",15,null],[13,"Float","","",15,null],[13,"Char","","",15,null],[13,"Str","","",15,null],[13,"Invalid","","",15,null],[5,"expr","","Parse and evalute an expression of a list of tokens.",null,null],[5,"macro_definition","","Parse and evaluate a macro definition from of a list of tokens.",null,null],[6,"CResult","","",null,null],[11,"fmt","","",16,null],[11,"eq","","",15,null],[11,"ne","","",15,null],[11,"clone","","",15,null],[11,"fmt","","",15,null],[11,"from","","",15,{"inputs":[{"name":"vec"}],"output":{"name":"evalresult"}}],[11,"add_assign","","",15,null],[11,"bitand_assign","","",15,null],[11,"bitor_assign","","",15,null],[11,"bitxor_assign","","",15,null],[11,"div_assign","","",15,null],[11,"mul_assign","","",15,null],[11,"rem_assign","","",15,null],[11,"shl_assign","","",15,null],[11,"shr_assign","","",15,null],[11,"sub_assign","","",15,null],[11,"new","","Create a new `IdentifierParser` with a set of known identifiers. When\na known identifier is encountered during parsing, it is substituted\nfor the value specified.",16,{"inputs":[{"name":"hashmap"}],"output":{"name":"identifierparser"}}],[11,"expr","","Parse and evalute an expression of a list of tokens.",16,null],[11,"macro_definition","","Parse and evaluate a macro definition from of a list of tokens.",16,null],[0,"token","cexpr","Representation of a C token",null,null],[3,"Token","cexpr::token","",null,null],[12,"kind","","",17,null],[12,"raw","","",17,null],[4,"Kind","","",null,null],[13,"Punctuation","","",18,null],[13,"Keyword","","",18,null],[13,"Identifier","","",18,null],[13,"Literal","","",18,null],[13,"Comment","","",18,null],[5,"remove_comments","","Remove all comment tokens from a vector of tokens",null,{"inputs":[{"name":"vec"}],"output":{"name":"vec"}}],[11,"eq","","",18,null],[11,"clone","","",18,null],[11,"fmt","","",18,null],[11,"eq","","",17,null],[11,"ne","","",17,null],[11,"clone","","",17,null],[11,"fmt","","",17,null],[11,"fmt","cexpr","",0,null]],"paths":[[4,"Error"],[4,"IResult"],[4,"ErrorKind"],[4,"Err"],[4,"Needed"],[4,"Input"],[4,"ConsumerState"],[3,"ProducerRepeat"],[3,"MemProducer"],[4,"Move"],[4,"FileProducerState"],[3,"FileProducer"],[3,"MapConsumer"],[3,"ChainConsumer"],[4,"CChar"],[4,"EvalResult"],[3,"IdentifierParser"],[3,"Token"],[4,"Kind"]]};
initSearch(searchIndex);
